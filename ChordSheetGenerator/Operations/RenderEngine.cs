using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using CSGen.Model;
using CSGen.Model.Renderer;
using Gtk;
using Cairo;

namespace CSGen.Operations
{
    public class RenderEngine : IPageRenderer
    {
        private Cairo.Context _cr;
        private AppSettings _appSettings = null;
        private PageSettings _pageSettings = new PageSettings();
        private SongData _song;
        private RenderOption _renderOption;

        // Calculated dimensions - altered by the scale (if applicable)
        private int _paperHeight = 0;
        private int _paperWidth = 0;

        // Calculated dimensions for display only
        private int _displayWidthExtent = 0;
        private int _displayHeightExtent = 0;

        /// <summary>
        ///   The node elements for the song.  These are generated by the ParseSong() method
        ///   and are sorted in order of display.
        /// </summary>
        private List<Model.Renderer.BaseNode> _rawLineNodes = new List<Model.Renderer.BaseNode>();

        /// <summary>
        ///   Page list generated when calculating the number of pages.
        /// </summary>
        private List<Model.Renderer.PageNode> _pages = new List<Model.Renderer.PageNode>();





        /// <summary>
        ///  Create and initialize the rendering engine.  This method sets all of the configuration settings
        ///  and parses the songs into the initial list of nodes.
        /// </summary>
        /// <param name="song">Song.</param>
        /// <param name="fonts">Fonts.</param>
        /// <param name="appSettings">App settings.</param>
        /// <param name="pageSetup">Page setup.</param>
        /// <param name="forDisplay">If set to <c>true</c> for display.</param>
        public RenderEngine(SongData song, AppSettings appSettings, PageSetup pageSetup, RenderOption renderOption)
        {
            _song = song;
            _renderOption = renderOption;
            _appSettings = appSettings;

            #region Page Setup
            _pageSettings.PaperHeight = pageSetup.GetPaperHeight(Unit.Pixel);
            _pageSettings.PaperWidth =  pageSetup.GetPaperWidth(Unit.Pixel);
            _pageSettings.PageHeight = pageSetup.GetPageHeight (Unit.Pixel);
            _pageSettings.PageWidth = pageSetup.GetPageWidth (Unit.Pixel);
            _pageSettings.TopMargin = pageSetup.GetTopMargin (Unit.Pixel);
            _pageSettings.LeftMargin = pageSetup.GetLeftMargin (Unit.Pixel);

            _paperHeight = Convert.ToInt32((long)_pageSettings.PaperHeight);
            _paperWidth = Convert.ToInt32((long)_pageSettings.PaperWidth);
            #endregion

            ParseSong(_song);
        }


        public PageSetup PageSetup { get { return new PageSetup(); } }
        public AppSettings AppSettings 
        { 
            get 
            { 
                return _appSettings; 
            } 
            set
            {
                // Do nothing (TODO: remove)
            }
        }

        public int Pages { get { return _pages.Count; } }

        /// <summary>
        ///  For display rendering only
        /// </summary>
        /// <value>The height of the page.</value>
        public int DisplayPaperHeight { get { return _paperHeight + Constants.Y_DISPLAY_MARGIN; } }


        public int ActualPaperHeight { get { return _paperHeight; } }

        /// <summary>
        ///  For display rendering only
        /// </summary>
        /// <value>The height of the max.</value>
        public int DisplayHeightExtent { get { return _displayHeightExtent; } }

        public int DisplayWidthExtent { get { return _displayWidthExtent; } }


        #region Parse Song Data
        private void ParseSong(SongData song)
        {
            #region Create Song Header Lines
            // Generate the standard song header (title and info)
            BeginRegion(PrintRegionType.Title);
            if (!string.IsNullOrEmpty (song.Title))
            {
                _rawLineNodes.Add(new Model.Renderer.TextNode(song.Title, _appSettings.GetFont(PrintFontType.Title)));
            }

            // Get the artist
            if (!string.IsNullOrEmpty (song.Artist))
            {
                _rawLineNodes.Add(new Model.Renderer.TextNode(song.Artist, _appSettings.GetFont(PrintFontType.SongInfo)));
            }

            if (!string.IsNullOrEmpty (song.Copyright))
            {
                _rawLineNodes.Add(new Model.Renderer.TextNode(song.Copyright, _appSettings.GetFont(PrintFontType.SongInfo)));
            }

            if (!string.IsNullOrEmpty (song.CCLI))
            {
                string text = string.Format("CCLI: {0}", song.CCLI);                   
                _rawLineNodes.Add(new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.SongInfo)));
            }

            if (!string.IsNullOrEmpty (song.Key))
            {
                string text = string.Format("Key: {0}", song.Key);                   
                _rawLineNodes.Add(new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.SongInfo)));
            }

            if (!string.IsNullOrEmpty (song.Capo))
            {
                string text = string.Format("Capo: {0}", song.Capo);                   
                _rawLineNodes.Add(new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.SongInfo)));
            }
            EndRegion();
            #endregion Create Song Header Lines

            string[] textLines = song.ContentText.Split ('\n');

            for (int i = 0; i < textLines.Length; i++)
            {
                ProcessSongLine (textLines [i]);
            }

        }


        private void ProcessSongLine(string line)
        {
            if (string.IsNullOrWhiteSpace (line))
            {
                _rawLineNodes.Add(new Model.Renderer.SpacerNode(_appSettings.GetFont(PrintFontType.Text)));
            } 
            else
            {

                MatchCollection matches = Constants._reSectionTags.Matches (line);
                if (matches.Count > 0)
                {
                    // For now we will just ignore them.
                    string tag = matches [0].Groups [1].Value;
                    switch (tag.ToLower ())
                    {
                        case "new_page":
                        case "np":
                        case "npp":
                            _rawLineNodes.Add(new CommandNode(CommandType.NewPage));
                            break;

                        case "start_of_chorus":
                            BeginRegion(PrintRegionType.ChorusBlock);
                            break;

                        case "start_of_bridge":
                            BeginRegion(PrintRegionType.BridgeBlock);
                            break;

                        case "start_of_verse":
                            BeginRegion(PrintRegionType.VerseBlock);
                            break;

                        case "start_of_versealt":
                            BeginRegion(PrintRegionType.VerseAltBlock);
                            break;

                        case "end_of_chorus":
                        case "end_of_bridge":
                        case "end_of_verse":
                        case "end_of_versealt":
                            EndRegion();
                            break;

                    }

                    line = line.Substring (matches [0].Length);
                    if (string.IsNullOrWhiteSpace(line))
                        return;
                }


                // Enter value tags (comments, etc.)
                matches = Constants._reValueTag.Matches (line);
                if (matches.Count > 0)
                {
                    string tag = matches [0].Groups[1].Value;
                    string text = matches [0].Groups [2].Value;

                    switch (tag.ToLower())
                    {
                        case "c":
                        case "cl":
                        case "comment":
                            _rawLineNodes.Add(new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.Comments)));
                            break;
                    }

                    line = line.Substring (matches [0].Length);
                    if (string.IsNullOrWhiteSpace(line))
                        return;                    
                }

                // Now, see if we have any chords to process. 
                matches = Constants._reChord.Matches (line);
                if (matches.Count > 0)
                {
                    Model.Renderer.ContainerNode currentLine = new CSGen.Model.Renderer.ContainerNode();

                    int txtPos = 0;
                    string tmpText = string.Empty;
                    string tmpChord = string.Empty;

                    foreach (Match match in matches)
                    {
                        tmpText = line.Substring(txtPos, match.Index - txtPos);

                        if(txtPos > 0 || !string.IsNullOrEmpty(tmpText))
                            AddChordBlock(currentLine, tmpChord, tmpText);

                        tmpChord = string.Format("{0}{1}{2}", match.Groups[1], match.Groups[2], match.Groups[4]);

                        txtPos = match.Index + match.Length;
                    }

                    if (tmpChord.Length > 0)
                    {
                        tmpText = line.Substring(txtPos);

                        AddChordBlock(currentLine, tmpChord, tmpText, lastChord: true);
                    }
                    else
                    {
                        currentLine.AddNode(new Model.Renderer.TextNode(line.Substring(txtPos), _appSettings.GetFont(PrintFontType.Text)));
                    }

                    _rawLineNodes.Add(currentLine);
                }
                else
                {
                    _rawLineNodes.Add(new Model.Renderer.TextNode(line, _appSettings.GetFont(PrintFontType.Text)));
                }

            }
        }


        private void AddChordBlock(Model.Renderer.ContainerNode container, string chord, string text, bool lastChord = false)
        {
            //if (chord.Length > 0)
            //{
            int spaces = text.Length - text.Trim().Length;
            container.AddNode(new Model.Renderer.ChordBlockNode(
                new Model.Renderer.TextNode(chord, _appSettings.GetFont(PrintFontType.Chords), 1)
                , new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.Text), spaces)
                , (!lastChord && (spaces == 0))
            ));                       
            //}
            //else
            //{
            //container.AddNode(new Model.Renderer.TextNode(text, _appSettings.GetFont(PrintFontType.Text), 1));
            //}

        }

        private void BeginRegion(PrintRegionType regionType)
        {
            _rawLineNodes.Add(new CommandNode(CommandType.BeginRegion, regionType));
        }

        private void EndRegion()
        {
            _rawLineNodes.Add(new CommandNode(CommandType.EndRegion));
        }

        #endregion

        #region Calculate Page Count
        public int CalculatePages(Cairo.Context cr)
        {
            _cr = cr;

            // Determine certain extents for all fonts for the current context.
            foreach(FontInfo font in _appSettings.Fonts)
            {
                font.SetExtents(_cr);
            }

            // Generate page nodes
            int pageNumber = 0;
            PageNode currentPage = CreateNewPage(pageNumber++);

            foreach (BaseNode line in _rawLineNodes)
            {
                if (line is CommandNode)
                {
                    CommandNode command = (CommandNode)line;
                    switch (command.CommandType)
                    {
                        case CommandType.NewPage:
                            currentPage = CreateNewPage(pageNumber++);
                            break;
                        case CommandType.BeginRegion:
                            currentPage.BeginRegion(command.RegionType);
                            break;

                        case CommandType.EndRegion:
                            currentPage.EndRegion();
                            break;
                    }
                }
                else
                {
                    if (!currentPage.TryAddLine(cr, line))
                    {
                        currentPage = CreateNewPage(pageNumber++);
                        currentPage.TryAddLine(cr, line);
                    }
                }
            }

            if (_renderOption == RenderOption.ScreenView)
            {
                //_displayHeightExtent = ((Y_DISPLAY_MARGIN + _paperHeight) * _pages.Count) + Y_DISPLAY_MARGIN;
                _displayHeightExtent = ((Constants.Y_DISPLAY_MARGIN + _paperHeight) * _pages.Count) + Constants.Y_DISPLAY_MARGIN;
                _displayWidthExtent = (Constants.X_DISPLAY_MARGIN * 2) + _paperWidth;
            }

            // Now update the total count for each page to render their header/footer information
            foreach (PageNode page in _pages)
            {
                page.SetTotalPageCount(_pages.Count);
            }

            return _pages.Count;
        }

        // Create and initialize the new page.
        private PageNode CreateNewPage(int pageNumber)
        {
            PageNode _newPage = new PageNode(pageNumber, _pageSettings, _appSettings, _song);
            _pages.Add(_newPage);

            return _newPage;
        }

        #endregion Calculate Page Count

        #region Draw Page
        public void DrawPage (int pageIndex, int offset = 0)
        {    
            double leftMargin = 0;
            if (_renderOption == RenderOption.ScreenView)
            {
                leftMargin = Constants.X_DISPLAY_MARGIN;
                offset += Constants.Y_DISPLAY_MARGIN;

                _pages[pageIndex].Draw(_cr, leftMargin, offset, PrintLayer.DisplayBackground);
            }
            _pages[pageIndex].Draw(_cr, leftMargin, offset, PrintLayer.Background);
            _pages[pageIndex].Draw(_cr, leftMargin, offset, PrintLayer.Text);

        }
        #endregion Draw Page
    }




}

